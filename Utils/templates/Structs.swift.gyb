%{
from genlib.templateutils import cond, Loop, swift_function_params

def adoptions(struct):
    result = ['CStructConvertible']
    if struct.extensible == 'in':
        result.append('Extensible')
    if struct.chained == 'in':
        result.append('Chained')
    return result
}%
import CWebGPU

% for struct in model.types_by_category('structure'):
public struct ${struct.swift_name}: ${', '.join(adoptions(struct))} {
    typealias CStruct = ${struct.c_name}

    % for member in struct.swift_members:
    public var ${member.swift_name}: ${member.swift_type}
    % end
    % if (struct.extensible or struct.chained) == 'in':

    public var nextInChain: Chained?
    % end

    public init(
        % for arg, loop in Loop(swift_function_params(struct.swift_members)):
        ${arg}${loop.sep()}
        % end
    ) {
        % for member in struct.swift_members:
        self.${member.swift_name} = ${member.swift_name}
        % end
    }
    % if (struct.extensible or struct.chained) == 'in':

    public init(
        % for arg in swift_function_params(struct.swift_members):
        ${arg},
        % end
        nextInChain: Chained?
    ) {
        % for member in struct.swift_members:
        self.${member.swift_name} = ${member.swift_name}
        % end
        self.nextInChain = nextInChain
    }
    % end

    init(cStruct: ${struct.c_name}) {
        % for member in struct.swift_members:
        self.${member.swift_name} = ${member.conversion.get_swift_value('cStruct.' + member.c_name, (member.length_member and 'cStruct.' + member.length_member.c_name) or member.length)}
        % end
    }

    func withCStruct<R>(_ body: (UnsafePointer<${struct.c_name}>) throws -> R) rethrows -> R {
        % if (struct.extensible or struct.chained) == 'in':
        return try self.nextInChain.withOptionalChainedCStruct { chainedCStruct in
        % end
        % for member in struct.members:
        % if member.conversion.requires_closure:
        return try ${member.conversion.get_closure_head(member.target_swift_name, prefix='self.')}
        % end
        % end
        var cStruct = ${struct.c_name}(
            % if struct.extensible:
            nextInChain: ${cond(struct.extensible == 'in', 'chainedCStruct', 'nil')}${cond(struct.members, ',')}
            % end
            % if struct.chained:
            chain: ${cond(struct.chained == 'in', f'WGPUChainedStruct(next: chainedCStruct, sType: {struct.s_type})', 'nil')}${cond(struct.members, ',')}
            % end
            % for member, loop in Loop(struct.members):
            ${member.c_name}: ${member.conversion.get_c_value(member.target_swift_name, prefix='self.')}${loop.sep()}
            % end
        )
        return try body(&cStruct)
        % for member in struct.members:
        % if member.conversion.requires_closure:
        ${member.conversion.get_closure_tail(member.target_swift_name, prefix='self.')}
        % end
        % end
        % if (struct.extensible or struct.chained) == 'in':
        }
        % end
    }
    % if struct.chained == 'in':

    public func withChainedCStruct<R>(_ body: (UnsafePointer<WGPUChainedStruct>) throws -> R) rethrows -> R {
        return try withCStruct { cStruct in
            let chainedCStruct = UnsafeRawPointer(cStruct).bindMemory(to: WGPUChainedStruct.self, capacity: 1)
            return try body(chainedCStruct)
        }
    }
    % end
}

% end
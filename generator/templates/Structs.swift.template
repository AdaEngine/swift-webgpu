import CWebGPU

{% for struct in model.types_by_category('structure') %}
public struct {{ struct.swift_name }}: CStructConvertible
    {%- if struct.extensible == 'in' %}, Extensible{% endif %}
    {% if struct.chained == 'in' %}, Chained{% endif %} {
    typealias CStruct = {{ struct.c_name }}

    {% for member in struct.swift_members %}
    public var {{ member.swift_name }}: {{ member.swift_type }}
    {% endfor %}
    {% if (struct.extensible or struct.chained) == 'in' %}

    public var nextInChain: Chained?
    {% endif %}

    public init(
    {%- for member in struct.swift_members -%}
    {{ member.swift_name }}: {{ member.swift_type }}
    {%- if member.default_swift_value %} = {{ member.default_swift_value }}{% endif %}
    {% if not loop.last %}, {% endif %}
    {%- endfor -%}
    ) {
        {% for member in struct.swift_members %}
        self.{{ member.swift_name }} = {{ member.swift_name }}
        {% endfor %}
    }

    {% if (struct.extensible or struct.chained) == 'in' %}
    public init(
    {%- for member in struct.swift_members %}{{ member.swift_name }}: {{ member.swift_type }}, {% endfor -%}
    nextInChain: Chained?) {
        {% for member in struct.swift_members %}
        self.{{ member.swift_name }} = {{ member.swift_name }}
        {% endfor %}
        self.nextInChain = nextInChain
    }
    {% endif %}
    {% if struct.has_c_struct_initializer %}
    init(cStruct: {{ struct.c_name }}) {
        {% for member in struct.swift_members %}
        self.{{ member.swift_name }} = {{ member.conversion.get_swift_value('cStruct.' + member.c_name, member.length_member and 'cStruct.' + member.length_member.c_name) }}
        {% endfor %}
    }
    {% endif %}

    func withCStruct<R>(_ body: (UnsafePointer<{{ struct.c_name }}>) throws -> R) rethrows -> R {
        {% if (struct.extensible or struct.chained) == 'in' %}
        return try self.nextInChain.withOptionalChainedCStruct { chainedCStruct in
        {% endif %}
        {% for member in struct.members %}
        {% if member.conversion.requires_closure %}
        return try {{ member.conversion.get_closure_head(member.target_swift_name, prefix='self.') }}
        {% endif %}
        {% endfor %}
        var cStruct = {{ struct.c_name }}(
            {% if struct.extensible %}
            nextInChain: {% if struct.extensible == 'in' %}chainedCStruct{% else %}nil{% endif %}{% if struct.members %}, {% endif %}

            {% endif %}
            {% if struct.chained %}
            chain: {% if struct.chained == 'in' %}WGPUChainedStruct(next: chainedCStruct, sType: {{ struct.s_type }}){% else %}nil{% endif %}{% if struct.members %}, {% endif %}

            {% endif %}
            {% for member in struct.members %}
            {{ member.c_name }}: {{ member.conversion.get_c_value(member.target_swift_name, prefix='self.') }}{% if not loop.last %}, {% endif %}

            {% endfor %}
        )
        return try body(&cStruct)
        {% for member in struct.members %}
        {% if member.conversion.requires_closure %}
        {{ member.conversion.get_closure_tail(member.target_swift_name, prefix='self.') }}
        {% endif %}
        {% endfor %}
        {% if (struct.extensible or struct.chained) == 'in' %}
        }
        {% endif %}
    }
    {% if struct.chained == 'in' %}

    public func withChainedCStruct<R>(_ body: (UnsafePointer<WGPUChainedStruct>) throws -> R) rethrows -> R {
        return try withCStruct { cStruct in
            let chainedCStruct = UnsafeRawPointer(cStruct).bindMemory(to: WGPUChainedStruct.self, capacity: 1)
            return try body(chainedCStruct)
        }
    }
    {% endif %}
}

{% endfor %}
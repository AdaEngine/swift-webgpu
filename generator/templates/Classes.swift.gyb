%{
from genlib.templateutils import cond, Loop, swift_function_params
}%
import CWebGPU

% for object in model.types_by_category('object'):
public class ${object.swift_name}: Object {
    private let handle: ${object.c_name}!

    /// Create a wrapper around an existing handle.
    ///
    /// The ownership of the handle is transferred to this class.
    ///
    /// - Parameter handle: The handle to wrap.
    public init(handle: ${object.c_name}!) {
        self.handle = handle
    }

    deinit {
        % for method in object.methods:
        % if method.is_callback_setter:
        ${method.swift_function_name}(nil)
        % end
        % end
        ${object.release_method_name}(self.handle)
    }

    /// Calls the given closure with the underlying handle.
    ///
    /// The underlying handle is guaranteed not to be released before the closure returns.
    ///
    /// - Parameter body: A closure to call with the underlying handle.
    public func withUnsafeHandle<R>(_ body: (${object.c_name}) throws -> R) rethrows -> R {
        return try withExtendedLifetime(self) {
            return try body(self.handle)
        }
    }
    % for method in object.methods:

    % if method.is_callback_setter:
    var _${method.swift_function_name}: UserData<${method.args[0].type.swift_name}>? = nil
    public func ${method.swift_function_name}(_ callback: ${method.args[0].type.swift_name}?) {
        self.withUnsafeHandle { handle_self in
            if let callback = callback {
                let userData = UserData(callback)
                self._${method.swift_function_name} = userData
                ${method.c_function_name}(handle_self, ${method.args[0].type.callback_function_name}, userData.toOpaque())
            } else {
                self._${method.swift_function_name} = nil
                ${method.c_function_name}(handle_self, nil, nil)
            }
        }
    }
    % else:
    % if method.is_getter:
    public var ${method.swift_function_name}: ${method.return_type.swift_name} {
    % else:
    public func ${method.swift_function_name}(
        % for arg, loop in Loop(swift_function_params(method.swift_args, method.hide_first_arg_label)):
        ${arg}${loop.sep()}
        % end
    % if method.return_type:
    ) -> ${method.return_type.swift_name} {
    % else:
    ) {
    % end
    % end
        self.withUnsafeHandle { handle_self in
            % for arg in method.args:
            % if arg.conversion.requires_closure:
            ${arg.conversion.get_closure_head(arg.target_swift_name)}
            % end
            % end
            % if method.return_type:
            let result = ${method.c_function_name}(
            % else:
            ${method.c_function_name}(
            % end
                handle_self${cond(method.args, ',')}
                % for arg, loop in Loop(method.args):
                ${arg.conversion.get_c_value(arg.target_swift_name)}${loop.sep()}
                % end
            )
            % if method.return_type:
            return ${method.return_conversion.get_swift_value('result')}
            % end
            % for arg in method.args:
            % if arg.conversion.requires_closure:
            ${arg.conversion.get_closure_tail(arg.target_swift_name)}
            % end
            % end
        }
    }
    % end
    % end
}

% end